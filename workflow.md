# Automata Simulator Workflow Documentation

This document explains the architecture, folder structure, file organization, and how all components work together across different modes.

## Table of Contents

1. [Folder Structure](#folder-structure)
2. [File Organization](#file-organization)
3. [System Architecture](#system-architecture)
4. [Workflow Overview](#workflow-overview)
5. [Mode-Specific Workflows](#mode-specific-workflows)
6. [Data Flow](#data-flow)

---

## Folder Structure

### Root Directories

#### `src/` - Source Code Implementation
Contains all C++ implementation files (.cpp), organized by functional modules:
- **`automata/`** - Core automaton implementations (builders, runners, utilities)
- **`parser/`** - Input parsing and validation logic
- **`modes/`** - Mode selection and dispatching
- **`reporting/`** - Output formatting and metrics collection
- **`evaluation/`** - Testing harnesses and performance evaluation

#### `include/` - Header Files
Mirrors `src/` structure with corresponding header files (.hpp) that define interfaces, data structures, and forward declarations.

#### `cli/` - Command-Line Interface
- **`main.cpp`** - Entry point, argument parsing, orchestration
- **`config.yaml`** - Default CLI configuration

#### `tests/` - Test Suite
- **`unit/`** - Unit tests for individual components
- **`integration/`** - End-to-end integration tests
- **`data/`** - Test fixtures and sample data
- **`test_main.cpp`** - Test runner entry point

#### `build/` - Build Artifacts
Generated by CMake, contains compiled binaries and object files:
- **`bin/automata_sim.exe`** - Main executable
- **`obj/`** - Compiled object files

#### `datasets/` - Sample Input Data
Organized by domain:
- **`dna/`** - DNA sequence samples (FASTA-like)
- **`rna/`** - RNA dot-bracket notation samples
- **`controls/`** - Control/test sequences

#### `config/` - Configuration Files
- **`defaults.yaml`** - Default runtime parameters
- **`reproducibility.md`** - Reproducibility notes and configuration documentation

#### `scripts/` - Automation Scripts
- **`run_perf.sh`** - Performance benchmarking script
- **`seed_datasets.py`** - Dataset generation utility

#### `docs/` - Documentation
- **`workflow.md`** - This file
- **`figures/`** - Diagrams and visualizations
- **`notes/`** - Development notes
- **`paper/`** - Academic paper materials

#### `tmp/` - Temporary Files
Scratch space for generated files during testing and development (git-ignored).

#### `BACKEND/` - Flask API Backend
Python Flask application that wraps the C++ simulator for web integration:
- **`app.py`** - Flask API endpoints
- **`requirements.txt`** - Python dependencies

---

## File Organization

### Core Automata Module (`src/automata/`)

#### Builders (`src/automata/builders/`)
- **`NfaBuilder.cpp`** - Constructs NFA from regex pattern using Thompson's construction
- **`DfaBuilder.cpp`** - Converts NFA to DFA via subset construction
- **`EfaBuilder.cpp`** - Builds Extended Finite Automaton for approximate matching (Hamming distance)
- **`PdaBuilder.cpp`** - Constructs Pushdown Automaton for nested structure validation

#### Runners (`src/automata/runners/`)
- **`NfaRunner.cpp`** - Simulates NFA execution (epsilon-closure, state set tracking)
- **`DfaRunner.cpp`** - Simulates DFA execution (single state, deterministic transitions)
- **`EfaRunner.cpp`** - Simulates EFA execution (mismatch budget tracking)
- **`PdaRunner.cpp`** - Simulates PDA execution (stack-based, balanced parentheses)
- **`RunnerFactory.cpp`** - Factory pattern: creates appropriate runner based on `AutomatonPlan`

#### Utilities (`src/automata/utils/`)
- **`StateSet.cpp`** - Efficient state set representation for NFA simulation
- **`MismatchAccounting.cpp`** - Tracks Hamming distance in EFA mode

### Parser Module (`src/parser/`)

- **`RegexParser.cpp`** - Parses regex patterns into postfix tokens (Shunting Yard algorithm)
- **`DatasetLoader.cpp`** - Loads sequence files (FASTA, plain text) into memory
- **`DotBracketValidator.cpp`** - Validates RNA dot-bracket notation syntax

### Mode Module (`src/modes/`)

- **`ModeDispatcher.cpp`** - Decides which automaton type to use based on `PatternSpec`
- **`ModeHeuristics.cpp`** - Optional heuristics for mode selection (if implemented)

### Reporting Module (`src/reporting/`)

- **`Reporter.cpp`** - Collects and formats sequence reports
- **`MetricsAggregator.cpp`** - Aggregates statistics (matches, acceptances, states visited)
- **`TraceFormatter.cpp`** - Formats execution traces for `--trace` output

### Evaluation Module (`src/evaluation/`)

- **`EvaluationHarness.cpp`** - Provides smoke test datasets (DNA/RNA)
- **`PerformanceSweep.cpp`** - Performance benchmarking utilities

### CLI (`cli/`)

- **`main.cpp`** - Main entry point:
  - Parses command-line arguments (`--pattern`, `--mode`, `--k`, `--input`, etc.)
  - Orchestrates workflow: load → dispatch → build → run → report
  - Handles JSON serialization for `--dump-automaton`
  - Formats colored terminal output

### Header Files (`include/`)

Mirror structure of `src/` with corresponding `.hpp` files:
- **`PatternSpec.hpp`** - User input specification (pattern, mode, mismatch budget, etc.)
- **`AutomatonPlan.hpp`** - Decided automaton type + spec
- **`IRunner.hpp`** - Abstract runner interface and `RunResult` structure
- **`TraceEvent.hpp`** - Trace event data structure

---

## System Architecture

### Component Layers

```
┌─────────────────────────────────────────┐
│         CLI (main.cpp)                  │  ← User Interface
├─────────────────────────────────────────┤
│      ModeDispatcher                     │  ← Mode Selection
├─────────────────────────────────────────┤
│  Parser  │  Builder  │  Runner Factory  │  ← Core Logic
├─────────────────────────────────────────┤
│  NFA/DFA/EFA/PDA Builders & Runners     │  ← Automaton Implementations
├─────────────────────────────────────────┤
│      Reporter & Metrics                 │  ← Output Generation
└─────────────────────────────────────────┘
```

### Key Data Structures

- **`PatternSpec`** - User requirements (pattern, mode preference, mismatch budget, dot-bracket flag)
- **`AutomatonPlan`** - Resolved plan (automaton kind + spec)
- **`RunResult`** - Execution results (matches, trace, states visited, stack depth)
- **`Nfa`, `Dfa`, `Efa`, `Pda`** - Automaton data structures

---

## Workflow Overview

### High-Level Flow

1. **Input Parsing** (`cli/main.cpp`)
   - Parse command-line arguments
   - Load dataset from file or use defaults
   - Construct `PatternSpec`

2. **Mode Decision** (`modes/ModeDispatcher.cpp`)
   - Analyze `PatternSpec` (mode preference, mismatch budget, dot-bracket flag)
   - Create `AutomatonPlan` with selected automaton kind

3. **Pattern Parsing** (`parser/RegexParser.cpp`)
   - Convert regex pattern to postfix tokens
   - (For PDA: pattern is dot-bracket notation, not regex)

4. **Automaton Construction** (`automata/builders/`)
   - Build appropriate automaton based on plan:
     - **NFA**: Thompson construction from regex
     - **DFA**: Subset construction from NFA
     - **EFA**: Layered states (position × mismatch count)
     - **PDA**: Stack-based rules for parentheses

5. **Runner Creation** (`automata/runners/RunnerFactory.cpp`)
   - Factory creates appropriate runner instance
   - Optionally captures automaton snapshot for JSON export

6. **Execution** (`automata/runners/*Runner.cpp`)
   - Run automaton on each input sequence
   - Collect matches, trace events, metrics

7. **Reporting** (`reporting/`)
   - Aggregate metrics across sequences
   - Format output (colored terminal, trace details)
   - Generate summary

---

## Mode-Specific Workflows

### Mode 1: DNA Exact (NFA)

**Purpose**: Exact regex pattern matching on DNA sequences

**Flow**:
1. `PatternSpec` has `requestedMode = Nfa` or `Auto` with no special flags
2. `ModeDispatcher` selects `AutomatonKind::Nfa`
3. `RegexParser` parses pattern (e.g., `"A(CG|TT)*"`) into tokens
4. `NfaBuilder` constructs NFA using Thompson's algorithm:
   - Literal characters → single-character transitions
   - `|` (union) → epsilon branches
   - `*` (Kleene star) → epsilon loops
   - Concatenation → sequential states
5. `NfaRunner` simulates:
   - Maintains set of active states (epsilon-closure)
   - Processes input character by character
   - Expands state set via epsilon transitions
   - Records matches when accept state is reached
6. `Reporter` outputs matches with positions

**Files Involved**:
- `src/parser/RegexParser.cpp` - Pattern parsing
- `src/automata/builders/NfaBuilder.cpp` - NFA construction
- `src/automata/runners/NfaRunner.cpp` - NFA simulation
- `src/automata/utils/StateSet.cpp` - State set management

---

### Mode 2: DNA Deterministic (DFA)

**Purpose**: Faster exact matching via deterministic automaton

**Flow**:
1. `PatternSpec` has `requestedMode = Dfa`
2. `ModeDispatcher` selects `AutomatonKind::Dfa`
3. `RegexParser` parses pattern
4. `NfaBuilder` builds NFA first (same as Mode 1)
5. `DfaBuilder` converts NFA to DFA:
   - Subset construction: DFA states = sets of NFA states
   - Epsilon-closure computation
   - Deterministic transition table (256 entries per state)
6. `DfaRunner` simulates:
   - Single active state (no sets needed)
   - Direct table lookup for transitions
   - Faster execution, higher memory usage
7. `Reporter` outputs matches

**Files Involved**:
- `src/parser/RegexParser.cpp`
- `src/automata/builders/NfaBuilder.cpp` - Build NFA first
- `src/automata/builders/DfaBuilder.cpp` - Convert to DFA
- `src/automata/runners/DfaRunner.cpp` - DFA simulation

**Key Difference**: DFA trades memory for speed (no state set tracking during execution)

---

### Mode 3: DNA Approximate (EFA)

**Purpose**: Pattern matching with up to k Hamming mismatches

**Flow**:
1. `PatternSpec` has `mismatchBudget > 0` (e.g., `--k 2`)
2. `ModeDispatcher` selects `AutomatonKind::Efa` (or explicit `--mode efa`)
3. Pattern is treated as literal string (not regex)
4. `EfaBuilder` constructs EFA:
   - States: `(position, mismatches)` pairs
   - Position: 0 to pattern_length
   - Mismatches: 0 to k
   - Transitions:
     - **Match**: `(pos, m) → (pos+1, m)` on exact character
     - **Mismatch**: `(pos, m) → (pos+1, m+1)` on any other character (if m < k)
5. `EfaRunner` simulates:
   - Tracks current position and mismatch count
   - Accepts when `position == pattern_length && mismatches <= k`
   - Records all valid match positions
6. `Reporter` outputs approximate matches

**Files Involved**:
- `src/automata/builders/EfaBuilder.cpp` - EFA construction
- `src/automata/runners/EfaRunner.cpp` - EFA simulation
- `src/automata/utils/MismatchAccounting.cpp` - Mismatch tracking

**Key Difference**: EFA handles errors/mutations in sequences (useful for bioinformatics)

---

### Mode 4: RNA Structural (PDA)

**Purpose**: Validate balanced base-pairing in RNA dot-bracket notation

**Flow**:
1. `PatternSpec` has `allowDotBracket = true` (via `--dot-bracket`)
2. `ModeDispatcher` selects `AutomatonKind::Pda`
3. Pattern is ignored (PDA validates structure, not pattern matching)
4. `PdaBuilder` constructs PDA:
   - States represent stack depth (0 = empty, 1+ = nested depth)
   - Rules: `(` pushes, `)` pops, `.` ignores
5. `PdaRunner` simulates:
   - Maintains stack (or stack depth counter)
   - On `(`: increment depth
   - On `)`: decrement depth (reject if depth < 0)
   - On `.`: no change
   - Accepts only if stack is empty at end
6. `DotBracketValidator` may pre-validate syntax
7. `Reporter` outputs validation result + max stack depth

**Files Involved**:
- `src/parser/DotBracketValidator.cpp` - Syntax validation
- `src/automata/builders/PdaBuilder.cpp` - PDA construction
- `src/automata/runners/PdaRunner.cpp` - PDA simulation

**Key Difference**: PDA handles context-free language (nested structures), not regular patterns

---

## Data Flow

### Complete Execution Path

```
User Input (CLI args)
    ↓
main.cpp: Parse arguments → PatternSpec
    ↓
ModeDispatcher: decide(PatternSpec) → AutomatonPlan
    ↓
DatasetLoader: loadSequences(path) → vector<string>
    ↓
RunnerFactory: create(plan, parser) → RunnerPtr
    ├─→ NfaBuilder.build(pattern) → Nfa
    │   └─→ (if DFA) DfaBuilder.build(Nfa) → Dfa
    ├─→ EfaBuilder.build(pattern, k) → Efa
    └─→ PdaBuilder.build() → Pda
    ↓
Runner.run(sequence) → RunResult
    ├─→ matches: vector<pair<start, end>>
    ├─→ trace: vector<TraceEvent>
    ├─→ statesVisited: size_t
    └─→ stackDepth: size_t (PDA only)
    ↓
MetricsAggregator: record(RunResult)
Reporter: add(SequenceReport)
    ↓
Reporter: summary(metrics) → string
    ↓
main.cpp: Output to stdout (colored/formatted)
```

### JSON Export Flow (--dump-automaton)

```
RunnerFactory.create(plan, parser, &snapshot)
    ↓
Snapshot captures automaton (Nfa/Dfa/Efa/Pda)
    ↓
main.cpp: serializeSnapshot(snapshot) → JSON string
    ↓
Write to file or stdout
```

### Trace Flow (--trace)

```
Runner.run(sequence)
    ↓
During simulation: emit TraceEvent objects
    ↓
RunResult.trace: vector<TraceEvent>
    ↓
TraceFormatter: format(RunResult) → string
    ↓
main.cpp: Output trace details
```

---

## Integration Points

### Between Modules

1. **Parser → Builder**: `RegexParser` provides tokens to `NfaBuilder`
2. **Builder → Runner**: Builders create automaton structures, runners consume them
3. **Runner → Reporter**: Runners produce `RunResult`, reporters aggregate them
4. **ModeDispatcher → Factory**: Plan determines which builder/runner to use

### External Dependencies

- **CMake**: Build system configuration
- **Makefile**: Convenience build commands
- **Flask Backend**: Web API wrapper (separate process)
- **Test Framework**: Unit/integration test runners

---

## Configuration and Customization

### Runtime Configuration

- **`config/defaults.yaml`**: Default parameters (if YAML parsing is implemented)
- **`cli/config.yaml`**: CLI-specific defaults
- **Environment variables**: `NO_COLOR` for disabling colored output

### Build Configuration

- **`CMakeLists.txt`**: CMake build configuration
- **`Makefile`**: Wrapper for common build commands

### Dataset Management

- **`datasets/`**: Pre-packaged sample data
- **`scripts/seed_datasets.py`**: Generate new datasets
- **`tests/data/`**: Test-specific fixtures

---

## Summary

The automata simulator follows a modular architecture where:

1. **CLI** handles user interaction and orchestration
2. **ModeDispatcher** selects the appropriate automaton type
3. **Parsers** process input (regex patterns, datasets)
4. **Builders** construct automata from specifications
5. **Runners** execute automata on sequences
6. **Reporters** format and aggregate results

Each mode (NFA, DFA, EFA, PDA) follows the same high-level flow but uses different builders and runners optimized for their specific use case. The system is designed to be extensible: adding a new automaton type requires implementing a builder, runner, and updating the factory/dispatcher.

